package ch09.sec07.exam01;

public class CarExample {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		Car 객체 생성
		Car car = new Car();
		
//		익명 자식 객체가 대입된 필드 사용
		car.run1();
		
//		익명 자식 객체가 대입된 로컬변수 사용
		car.run2();
		
//		익명 자식 객체가 대입된 매개변수 사용
		car.run3(new Tire(){
			@Override
			public void roll() {
				System.out.println("익명 자식 Tire 객체 3이 굴러갑니다.");
			}
		});
	}
//	익명개체: 이름이 없는 객체임. 명시적으로 클래스를 선언하지 않아서 쉽게 객체를 생성할 수 있는 장점이 있음.
//	익명개체는 필드값, 로컬변수값, 매개변수값으로 주로 사용됨.
	
//	익명개체 사용법: 클래스를 상속하거나, 인터페이스를 구현해야만 생성이 가능함.
//				 ㄴ-> 클래스를 상속해서 만들경우 익명 자식 객체라고하고, 인터페이스를 구현해서 만들 경우 익명 구현 객체라고 함.
//	이 패키지에선 Car클래스에서 부모클래스를 상속받아서, 익명 자식 객체를 만듬. 이렇게 생성된 객체는 부모타입의 필드, 로컬변수, 매개변수의 값으로 대입 가능.
//	중괄호{} 블록 안의 필드와 메소드는 익명 자식 객체가 가져야 할 멤버로, 중괄호 블록 안에서만 사용 가능함. 이유: 익명 자식 객체는 부모 타입에 대입되므로
//	부모 타입에 선언된 멤버만 접근할 수 있기 때문임. -> 고로 중괄호 블록 안에는 주로 부모 메소드를 재정의하는 코드가 옴.
//	ch09.sec07.exam01의 패키지 내부의 클래스들은 익명 자식객체로 부모타입의 필드, 로컬변수, 매개변수의 값으로 대입 가능한걸 모두 사용한 코드임.
	
//	익명 자식 객체가 부모 타입에 대입되면 부모 메소드 roll()을 호출할 경우, 재정의된 익명 자식 객체의 roll() 메소드가 실행되는걸 볼 수 있다. (다형성)
}
